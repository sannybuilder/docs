# Директивы

Препроцессорные **директивы** - это специальные слова, которые указывают компилятору на необходимое поведение в процессе компиляции. Они начинаются с символа `$` и заключены в фигурные скобки `{}`.

## $VERSION

{% hint style="warning" %}
Эта директива не используется начиная с версии v3.1.0
{% endhint %}

Устанавливает какая версия [опкодов](../scm-documentation/opcodes-list-scm.ini.md) будет использована во время компиляции.

Синтаксис:  
`{$VERSION x.y.zzzz}`

* `X`- ID [режима редактирования](../edit-modes.md)
* `y` - порядок параметров
  * `0` - оригинальный, все параметры идут последовательно 0, 1, 2 и т.д.
  * `1` - модифицированный порядок, некоторые параметры переставлены
* `zzzz` - номер ревизии

По умолчанию компилятор загружает версию `<текущий режим>.1.0000`

## $VERSION\_RESTORE

{% hint style="warning" %}
Эта директива не используется начиная с версии v3.1.0
{% endhint %}

Восстанавливает версию, которая использовалась до директивы `$VERSION`.

Синтаксис:  
`{$VERSION_RESTORE}`

## $INCLUDE

Подключает внешний текстовый файл к исходнику. Когда компилятор находит указанную директиву, он открывает файл по пути, переданному в качестве параметра директивы и продолжает компиляцию того кода, который записан во внешнем файле. Когда компилятор достигает конца данного файла, он возвращается обратно в предыдущий файл.

Синтаксис:  
`{$INCLUDE путь\к\файлу}`

```text
{$INCLUDE loadwav.txt}
{$INCLUDE C:\dev\getarrayindex.txt}
```

Если указан относительный путь, компилятор ищет файл в следующем порядке:

1. папка, где находится файл, содержащий данную директиву
2. `Sanny Builder\data\`
3. корневая папка Sanny Builder
4. корневая папка игры

Если компилятор не может найти файл относительно ни одной из указанных папок это вызовет ошибку.

Вы можете использовать данную директиву неограниченное число раз. Вкладываемые файлы могут также содержать в себе данную директиву.

{% hint style="info" %}
Короткая форма этой директивы `$I`.
{% endhint %}

## $EXTERNAL

Заставляет скомпилировать файл как внешний скрипт. Получившийся файл будет без заголовка и с локальными [метками](data-types.md#metki) как `.scm` файл из `script.img`. Использование данной директивы подразумевает, что в файле содержится только один скрипт или одна миссия.

Аналогом использования данной директивы является [опция](../console.md#skip_scm_header) `SKIP_SCM_HEADER`. Данную опцию также можно переключить на главной панели инструментов.

Синтаксис:  
`{$EXTERNAL}`

{% hint style="info" %}
Короткая форма этой директивы `$E`.
{% endhint %}

## $CLEO

Является аналогом директивы `$E`, однако полученный файл автоматически копируется в директорию `игра\CLEO`, и получает расширение, указанное в директиве.

Синтаксис:  
`{$CLEO <расширение файла>}`

`расширение файла` - опциональный параметр, который определяет какое расширение получит скомпилированный файл. Начинается с `.`. По умолчанию равен `.cs`.

```text
{$CLEO .cm} // файл получит расширение .cm
{$CLEO} // файл получит расширение по умолчанию .cs
```

Эта директива предназначена максимально упростить создание CLEO скриптов.

## $NOSOURCE

Запрещает компилятору добавлять в конечный файл исходный код скрипта. 

Если эта директива отсутствует, то при наличии директив `$EXTERNAL` или `$CLEO` и при включенной [опции](../editor/options/general.md#dobavlyat-dopolnitelnuyu-informaciyu-v-scm) `Добавлять доп. информацию в SCM`, Sanny Builder добавит исходный код в конец файла для последующего использования при дизассемблировании.

Синтаксис:  
`{$NOSOURCE}`

## $OPCODE

Регистрирует новый опкод. 

Обычно описания всех опкодов содержатся в [специальном файле](../scm-documentation/opcodes-list-scm.ini.md), по одному для каждой игры. Но иногда необходимо добавить новый опкод для использования в текущем скрипте. Директива `$OPCODE` делает это возможным без редактирования оригинального списка опкодов.

Синтаксис:  
`{$OPCODE <описание опкода>}`  
 или  
`{$OPCODE <путь к файлу с описанием>}`  
 или  
`{$OPCODE}`

`описание опкода` - директива принимает описание опкода в том же [формате](../scm-documentation/opcodes-list-scm.ini.md#opkody), что и файл INI:

```text
{$OPCODE 0CCC=1,my_new_opcode %1d%}
```

`путь к файлу с описанием` - директива также принимает путь к файлу в качестве параметра. Этот файл должен содержать в себе только описания опкодов, которые будут загружены компилятором. Если указан относительный путь, компилятор ищет файл по тем же правилам, что и в директиве `$INCLUDE`.

```text
{$OPCODE additional_opcodes.ini}
```

Если директива использована без какого-либо параметра, это ведет к загрузке оригинального списка опкодов и отмене всех сделанных изменений.

```text
{$OPCODE}
```

{% hint style="info" %}
Короткая форма этой директивы `$O`.
{% endhint %}





